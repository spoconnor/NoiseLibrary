using System;
using System.Collections.Generic;

namespace NoiseLibrary
{

    /*
    The BasisFunction function encapsulates basic noise generators. 
    The function is customizable; you can choose what type of noise to generate and 
    what interpolation style to use. The types of basis functions are enumerated as:

    VALUE,
    GRADIENT,
    GRADVAL,
    SIMPLEX,
    WHITE

    The interpolation types are enumerated as:

    NONE,
    LINEAR,
    CUBIC,
    QUINTIC

    VALUE represents value noise which is generated by assigning a pseudo-random value in 
    the range (-1,1) to every lattice point in the integral grid, then interpolating the 
    corner values of the conceptual "cell" in which an input coordinate location is enclosed.


    VALUE noise

    GRADIENT represents Perlin's original noise function. It is similar to VALUE noise in 
    that values are assigned to each lattice point and interpolated; however; the values 
    are calculated as the evaluation of a wavelet function centered on the lattice point. 
    The result is smoother and with fewer grid artifacts. Gradient noise has the effect 
    that the lattice wavelets evaluate to 0 at the lattice points, so the gradient function 
    evaluates to 0 at all integral points in the grid, a fact that can have consequences in 
    some applications, resulting in the appearance of grid-oriented artifacts.


    GRADIENT noise

    GRADVAL is a hybrid calculated as the sum of GRADIENT and VALUE noises, and is an attempt 
    to "hide" the grid-oriented artifacts that sometimes arise from GRADIENT noise alone. 
    While the method does fix the problem of lattice points evaluating to 0, since both 
    GRADIENT and VALUE are tied to the grid, artifacts can still occur. See Figure 3 for 
    an example of GRADVAL noise.


        GRADVAL noise

        SIMPLEX is a form of Perlin's improved noise function. Rather than interpolating 
        the edges of a conceptual hyper-cube in N-dimensional space to obtain the noise value, 
        simplex noise calculates a weighted sum of values assigned to the vertices of 
        an N-dimensional "simplex". A "simplex" is the term for the simplest shape that 
        can tile a given N-dimensional shape. For a 2D space, the simplex is an equilateral 
        triangle. For the 3D space, it is a tetrahedron. Because a simplex has fewer vertices 
        than the corresponding grid shape of the space, fewer calculations per sample point 
        are required for simplex noise than for gradient or value noises. However, since 
        simplex noise is calculated as a weighted sum of vertex contributions, rather than 
        as an interpolation of lattice corners, simplex noise will ignore the interptype 
        parameter passed in the constructor or via the setInterp() method. Since the size 
        of an N-space's simplex is smaller than the corresponding unit of a grid lattice, 
        simplex noise appears "denser" across a given region than gradient or value noise, 
        a fact that should be taken into consideration. Simplex noise goes a long way 
        toward reducing the appearance of grid-aligned artifacts. However, the noise is 
        still aligned on a lattice structure, so artifacts are still there, noticeable 
        or not. They often show up as diagonal lines slanting across the function.


        SIMPLEX noise

        WHITE noise is a representation of chaotic, random noise. 
        Whereas the previous variants have all generated what is called a "continuously random" 
        signal, WHITE noise generates a truly chaotic signal with no pattern at all.


        WHITE noise

        Aside from being able to assignt he type of noise generated, the user can also assign 
        the type of interpolation used. This parameter only applies to the variants of 
        VALUE, GRADVAL and GRADIENT. As described, SIMPLEX performs a weighted sum, 
        and WHITE noise performs no interpolation at all. The types of interpolation are as follows:

        NONE: No interpolation at all is performed.


        VALUE noise, NONE interp

        LINEAR: Lattice values are linearly interpolated.


        VALUE noise, LINEAR interp

        CUBIC:: Lattice values are performed using cubic interpolation.


        VALUE noise, CUBIC interp

        QUINTIC: Lattice values are interpolated using quintic interpolation. 
        This results in the highest quality of noise.


        VALUE noise, QUINTIC interp

        In order to mitigate the occurrence of grid-aligned artifacts, especially in fractal functions,
        basis functions incorporate a 2D axial rotation (for 2D variants) and a 3D axial rotation 
        (for 3D and above variants) that are seeded to randomized axis/angles when the function is constructed. 
        These randomized rotations alter the alignment of the function with the lattice boundaries,
        and serve in most cases to help obscure the grid artifacts.

        BasisFunction serves as the primary signal generator for ANL.
*/

    public class CImplicitBasisFunction : CImplicitModuleBase
    {
        public enum EBasisTypes
        {
            VALUE,
            GRADIENT,
            GRADVAL,
            SIMPLEX,
            WHITE
        }

        public enum EInterpTypes
        {
            NONE,
            LINEAR,
            CUBIC,
            QUINTIC
        }

        private double[] m_scale, m_offset;
        private anl.interp_func m_interp;
        private anl.noise_func2 m_2d;
        private anl.noise_func3 m_3d;
        private anl.noise_func4 m_4d;
        private anl.noise_func6 m_6d;
        private uint m_seed;

        private double[,] m_rotmatrix;
        private double cos2d, sin2d;
        private bool m_rotatedomain;

        public CImplicitBasisFunction() : base()
        {
            m_rotmatrix = new double[3, 3];
            m_scale = new double[4];
            m_offset = new double[4];

            m_rotatedomain = true;
            setType(EBasisTypes.GRADIENT);
            setInterp(EInterpTypes.QUINTIC);
            setSeed(1000);
        }
        public CImplicitBasisFunction(EBasisTypes type, EInterpTypes interp, bool rotatedomain) : base()
        {
            m_rotmatrix = new double[3, 3];
            m_scale = new double[4];
            m_offset = new double[4];

            m_rotatedomain = rotatedomain;
            setType(type);
            setInterp(interp);
            setSeed(1000);
        }

        override public void setSeed(uint seed)
        {
            m_seed = seed;
            LCG lcg = new LCG();
            lcg.setSeed(seed);

            if (m_rotatedomain)
            {
                double ax, ay, az;
                double len;

                ax = lcg.get01();
                ay = lcg.get01();
                az = lcg.get01();
                len = Math.Sqrt(ax * ax + ay * ay + az * az);
                ax /= len;
                ay /= len;
                az /= len;
                setRotationAngle(ax, ay, az, (lcg.get01() * 3.141592 * 2.0));
                double angle = (lcg.get01() * 3.14159265 * 2.0);
                cos2d = Math.Cos(angle);
                sin2d = Math.Sin(angle);
            }
            else
            {
                setNoRotation();
            }
        }

        public void setType(EBasisTypes type)
        {
            switch (type)
            {
                case EBasisTypes.VALUE: m_2d = anl.value_noise2D; m_3d = anl.value_noise3D; m_4d = anl.value_noise4D; m_6d = anl.value_noise6D; break;
                case EBasisTypes.GRADIENT: m_2d = anl.gradient_noise2D; m_3d = anl.gradient_noise3D; m_4d = anl.gradient_noise4D; m_6d = anl.gradient_noise6D; break;
                case EBasisTypes.GRADVAL: m_2d = anl.gradval_noise2D; m_3d = anl.gradval_noise3D; m_4d = anl.gradval_noise4D; m_6d = anl.gradval_noise6D; break;
                case EBasisTypes.WHITE: m_2d = anl.white_noise2D; m_3d = anl.white_noise3D; m_4d = anl.white_noise4D; m_6d = anl.white_noise6D; break;
                case EBasisTypes.SIMPLEX: m_2d = anl.simplex_noise2D; m_3d = anl.simplex_noise3D; m_4d = anl.simplex_noise4D; m_6d = anl.simplex_noise6D; break;
                default: m_2d = anl.gradient_noise2D; m_3d = anl.gradient_noise3D; m_4d = anl.gradient_noise4D; m_6d = anl.gradient_noise6D; break;
            }
            setMagicNumbers(type);
        }

        public void setInterp(EInterpTypes interp)
        {
            switch (interp)
            {
                case EInterpTypes.NONE: m_interp = anl.noInterp; break;
                case EInterpTypes.LINEAR: m_interp = anl.linearInterp; break;
                case EInterpTypes.CUBIC: m_interp = anl.hermiteInterp; break;
                default: m_interp = anl.quinticInterp; break;
            }
        }

        public override double get(double x, double y)
        {
            double nx, ny;
            nx = x * cos2d - y * sin2d;
            ny = y * cos2d + x * sin2d;
            return m_2d(nx, ny, m_seed, m_interp);
        }
        public override double get(double x, double y, double z)
        {
            double nx, ny, nz;
            nx = (m_rotmatrix[0, 0] * x) + (m_rotmatrix[1, 0] * y) + (m_rotmatrix[2, 0] * z);
            ny = (m_rotmatrix[0, 1] * x) + (m_rotmatrix[1, 1] * y) + (m_rotmatrix[2, 1] * z);
            nz = (m_rotmatrix[0, 2] * x) + (m_rotmatrix[1, 2] * y) + (m_rotmatrix[2, 2] * z);
            return m_3d(nx, ny, nz, m_seed, m_interp);
        }
        public override double get(double x, double y, double z, double w)
        {
            double nx, ny, nz;
            nx = (m_rotmatrix[0, 0] * x) + (m_rotmatrix[1, 0] * y) + (m_rotmatrix[2, 0] * z);
            ny = (m_rotmatrix[0, 1] * x) + (m_rotmatrix[1, 1] * y) + (m_rotmatrix[2, 1] * z);
            nz = (m_rotmatrix[0, 2] * x) + (m_rotmatrix[1, 2] * y) + (m_rotmatrix[2, 2] * z);
            return m_4d(nx, ny, nz, w, m_seed, m_interp);
        }
        public override double get(double x, double y, double z, double w, double u, double v)
        {
            double nx, ny, nz;
            nx = (m_rotmatrix[0, 0] * x) + (m_rotmatrix[1, 0] * y) + (m_rotmatrix[2, 0] * z);
            ny = (m_rotmatrix[0, 1] * x) + (m_rotmatrix[1, 1] * y) + (m_rotmatrix[2, 1] * z);
            nz = (m_rotmatrix[0, 2] * x) + (m_rotmatrix[1, 2] * y) + (m_rotmatrix[2, 2] * z);
            return m_6d(nx, ny, nz, w, u, v, m_seed, m_interp);
        }

        void setNoRotation()
        {
            m_rotatedomain = false;
            m_rotmatrix[0, 0] = 1;
            m_rotmatrix[1, 0] = 0;
            m_rotmatrix[2, 0] = 0;

            m_rotmatrix[0, 1] = 0;
            m_rotmatrix[1, 1] = 1;
            m_rotmatrix[2, 1] = 0;

            m_rotmatrix[0, 2] = 0;
            m_rotmatrix[1, 2] = 0;
            m_rotmatrix[2, 2] = 1;

            cos2d = 1;
            sin2d = 0;
        }

        void setRotationAngle(double x, double y, double z, double angle)
        {
            m_rotatedomain = true;
            m_rotmatrix[0, 0] = (1 + (1 - Math.Cos(angle)) * (x * x - 1));
            m_rotmatrix[1, 0] = (-z * Math.Sin(angle) + (1 - Math.Cos(angle)) * x * y);
            m_rotmatrix[2, 0] = (y * Math.Sin(angle) + (1 - Math.Cos(angle)) * x * z);

            m_rotmatrix[0, 1] = (z * Math.Sin(angle) + (1 - Math.Cos(angle)) * x * y);
            m_rotmatrix[1, 1] = (1 + (1 - Math.Cos(angle)) * (y * y - 1));
            m_rotmatrix[2, 1] = (-x * Math.Sin(angle) + (1 - Math.Cos(angle)) * y * z);

            m_rotmatrix[0, 2] = (-y * Math.Sin(angle) + (1 - Math.Cos(angle)) * x * z);
            m_rotmatrix[1, 2] = (x * Math.Sin(angle) + (1 - Math.Cos(angle)) * y * z);
            m_rotmatrix[2, 2] = (1 + (1 - Math.Cos(angle)) * (z * z - 1));

            cos2d = Math.Cos(angle);
            sin2d = Math.Sin(angle);
        }

        private void setMagicNumbers(EBasisTypes type)
        {
            // This function is a damned hack.
            // The underlying noise functions don't return values in the range [-1,1] cleanly, and the ranges vary depending
            // on basis type and dimensionality. There's probably a better way to correct the ranges, but for now I'm just
            // setting the magic numbers m_scale and m_offset manually to empirically determined magic numbers.
            switch (type)
            {
                case EBasisTypes.VALUE:
                    {
                        m_scale[0] = 1.0f; m_offset[0] = 0.0f;
                        m_scale[1] = 1.0f; m_offset[1] = 0.0f;
                        m_scale[2] = 1.0f; m_offset[2] = 0.0f;
                        m_scale[3] = 1.0f; m_offset[3] = 0.0f;
                    }
                    break;

                case EBasisTypes.GRADIENT:
                    {
                        m_scale[0] = 1.86848f; m_offset[0] = -0.000118f;
                        m_scale[1] = 1.85148f; m_offset[1] = -0.008272f;
                        m_scale[2] = 1.64127f; m_offset[2] = -0.01527f;
                        m_scale[3] = 1.92517f; m_offset[3] = 0.03393f;
                    }
                    break;

                case EBasisTypes.GRADVAL:
                    {
                        m_scale[0] = 0.6769f; m_offset[0] = -0.00151f;
                        m_scale[1] = 0.6957f; m_offset[1] = -0.133f;
                        m_scale[2] = 0.74622f; m_offset[2] = 0.01916f;
                        m_scale[3] = 0.7961f; m_offset[3] = -0.0352f;
                    }
                    break;

                case EBasisTypes.WHITE:
                    {
                        m_scale[0] = 1.0f; m_offset[0] = 0.0f;
                        m_scale[1] = 1.0f; m_offset[1] = 0.0f;
                        m_scale[2] = 1.0f; m_offset[2] = 0.0f;
                        m_scale[3] = 1.0f; m_offset[3] = 0.0f;
                    }
                    break;

                default:
                    {
                        m_scale[0] = 1.0f; m_offset[0] = 0.0f;
                        m_scale[1] = 1.0f; m_offset[1] = 0.0f;
                        m_scale[2] = 1.0f; m_offset[2] = 0.0f;
                        m_scale[3] = 1.0f; m_offset[3] = 0.0f;
                    }
                    break;
            }
        }
    }
}
